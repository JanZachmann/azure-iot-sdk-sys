diff -ruN iot-hub-device-update/src/adu_types/inc/aduc/adu_types.h iot-hub-device-update_new/src/adu_types/inc/aduc/adu_types.h
--- iot-hub-device-update/src/adu_types/inc/aduc/adu_types.h	2021-10-28 12:39:27.261045901 +0200
+++ iot-hub-device-update_new/src/adu_types/inc/aduc/adu_types.h	2021-10-28 10:48:39.761094462 +0200
@@ -8,23 +8,23 @@
 #define ADUC_ADU_TYPES_H
 
 #include <aduc/c_utils.h>
-#include <aduc/logging.h>
+// #include <aduc/logging.h>
 #include <stdbool.h>
 
 EXTERN_C_BEGIN
 /**
  * @brief ADU Client launch arguments.
  */
-typedef struct tagADUC_LaunchArguments
-{
-    int argc; /**< Size of argv */
-    char** argv; /**< Command-line arguments */
-    ADUC_LOG_SEVERITY logLevel; /**< Log level */
-    char* connectionString; /**< Device connection string from command-line. */
-    bool iotHubTracingEnabled; /**< Whether to enable logging from IoT Hub SDK */
-    bool showVersion; /**< Show an agent version */
-    bool healthCheckOnly; /**< Only check agent health. Doesn't process any data or messages from services. */
-} ADUC_LaunchArguments;
+// typedef struct tagADUC_LaunchArguments
+// {
+//     int argc; /**< Size of argv */
+//     char** argv; /**< Command-line arguments */
+//     ADUC_LOG_SEVERITY logLevel; /**< Log level */
+//     char* connectionString; /**< Device connection string from command-line. */
+//     bool iotHubTracingEnabled; /**< Whether to enable logging from IoT Hub SDK */
+//     bool showVersion; /**< Show an agent version */
+//     bool healthCheckOnly; /**< Only check agent health. Doesn't process any data or messages from services. */
+// } ADUC_LaunchArguments;
 
 typedef enum tagADUC_ConnType
 {
@@ -81,4 +81,4 @@
 
 EXTERN_C_END
 
-#endif // ADUC_ADU_TYPES_H
\ Kein Zeilenumbruch am Dateiende.
+#endif // ADUC_ADU_TYPES_H
diff -ruN iot-hub-device-update/src/adu_types/src/adu_types.c iot-hub-device-update_new/src/adu_types/src/adu_types.c
--- iot-hub-device-update/src/adu_types/src/adu_types.c	2021-10-28 12:39:27.261045901 +0200
+++ iot-hub-device-update_new/src/adu_types/src/adu_types.c	2021-10-28 10:48:39.765094462 +0200
@@ -5,29 +5,29 @@
  */
 
 #include <aduc/adu_types.h>
-#include <aduc/logging.h>
+// #include <aduc/logging.h>
 #include <stdlib.h>
 #include <string.h>
 
-/**
- * @brief Returns the string associated with @p connType
- * @param connType ADUC_ConnType to be stringified
- * @returns if the ADUC_ConnType exists then the string version of the value is returned, "" otherwise
- */
-const char* ADUC_ConnType_ToString(const ADUC_ConnType connType)
-{
-    switch (connType)
-    {
-    case ADUC_ConnType_NotSet:
-        return "ADUC_ConnType_NotSet";
-    case ADUC_ConnType_Device:
-        return "ADUC_ConnType_Device";
-    case ADUC_ConnType_Module:
-        return "ADUC_ConnType_Module";
-    }
+// /**
+//  * @brief Returns the string associated with @p connType
+//  * @param connType ADUC_ConnType to be stringified
+//  * @returns if the ADUC_ConnType exists then the string version of the value is returned, "" otherwise
+//  */
+// const char* ADUC_ConnType_ToString(const ADUC_ConnType connType)
+// {
+//     switch (connType)
+//     {
+//     case ADUC_ConnType_NotSet:
+//         return "ADUC_ConnType_NotSet";
+//     case ADUC_ConnType_Device:
+//         return "ADUC_ConnType_Device";
+//     case ADUC_ConnType_Module:
+//         return "ADUC_ConnType_Module";
+//     }
 
-    return "<Unknown>";
-}
+//     return "<Unknown>";
+// }
 /**
  * @brief DeAllocates the ADUC_ConnectionInfo object
  * @param info the ADUC_ConnectionInfo object to be de-allocated
@@ -50,42 +50,42 @@
     info->connType = ADUC_ConnType_NotSet;
 }
 
-/**
- * @brief Scans the connection string and returns the connection type related to the string
- * @details The connection string must use the valid, correct format for the DeviceId and/or the ModuleId
- * e.g.
- * "DeviceId=some-device-id;ModuleId=some-module-id;"
- * If the connection string contains the DeviceId it is an ADUC_ConnType_Device
- * If the connection string contains the DeviceId AND the ModuleId it is an ADUC_ConnType_Module
- * @param connectionString the connection string to scan
- * @returns the connection type for @p connectionString
- */
-ADUC_ConnType GetConnTypeFromConnectionString(const char* connectionString)
-{
-    ADUC_ConnType result = ADUC_ConnType_NotSet;
-
-    if (connectionString == NULL)
-    {
-        Log_Debug("Connection string passed to GetConnTypeFromConnectionString is NULL");
-        return ADUC_ConnType_NotSet;
-    }
-
-    if (strstr(connectionString, "DeviceId=") != NULL)
-    {
-        if (strstr(connectionString, "ModuleId=") != NULL)
-        {
-            result = ADUC_ConnType_Module;
-        }
-        else
-        {
-            result = ADUC_ConnType_Device;
-        }
-    }
-    else
-    {
-        Log_Debug(
-            "Connection string passed to GetConnTypeFromConnectionString does not contain a DeviceId or ModuleId value");
-    }
+// /**
+//  * @brief Scans the connection string and returns the connection type related to the string
+//  * @details The connection string must use the valid, correct format for the DeviceId and/or the ModuleId
+//  * e.g.
+//  * "DeviceId=some-device-id;ModuleId=some-module-id;"
+//  * If the connection string contains the DeviceId it is an ADUC_ConnType_Device
+//  * If the connection string contains the DeviceId AND the ModuleId it is an ADUC_ConnType_Module
+//  * @param connectionString the connection string to scan
+//  * @returns the connection type for @p connectionString
+//  */
+// ADUC_ConnType GetConnTypeFromConnectionString(const char* connectionString)
+// {
+//     ADUC_ConnType result = ADUC_ConnType_NotSet;
+
+//     if (connectionString == NULL)
+//     {
+//         Log_Debug("Connection string passed to GetConnTypeFromConnectionString is NULL");
+//         return ADUC_ConnType_NotSet;
+//     }
+
+//     if (strstr(connectionString, "DeviceId=") != NULL)
+//     {
+//         if (strstr(connectionString, "ModuleId=") != NULL)
+//         {
+//             result = ADUC_ConnType_Module;
+//         }
+//         else
+//         {
+//             result = ADUC_ConnType_Device;
+//         }
+//     }
+//     else
+//     {
+//         Log_Debug(
+//             "Connection string passed to GetConnTypeFromConnectionString does not contain a DeviceId or ModuleId value");
+//     }
 
-    return result;
-}
\ Kein Zeilenumbruch am Dateiende.
+//     return result;
+// }
diff -ruN iot-hub-device-update/src/utils/c_utils/src/string_c_utils.c iot-hub-device-update_new/src/utils/c_utils/src/string_c_utils.c
--- iot-hub-device-update/src/utils/c_utils/src/string_c_utils.c	2021-10-28 12:39:10.169046025 +0200
+++ iot-hub-device-update_new/src/utils/c_utils/src/string_c_utils.c	2021-10-28 10:50:23.731000000 +0200
@@ -22,321 +22,321 @@
  */
 #define ADUC_STRING_FORMAT_MAX_LENGTH 512
 
-/**
- * @brief Read a value from a delimited file and return the value found.
- * The file is in form "key=value", and keys are case sensitive.
- * Value returned has whitespace trimmed from both ends.
- *
- * @param fileName Filename of delimited file
- * @param key Key to find
- * @param value Value found for @p Key
- * @param valueLen Size of buffer for @p value
- * @return true if value found, false otherwise.
- */
-_Bool ReadDelimitedValueFromFile(const char* fileName, const char* key, char* value, unsigned int valueLen)
-{
-    _Bool foundKey = false;
-    const unsigned int bufferLen = 1024;
-    char buffer[bufferLen];
-
-    if (valueLen < 2)
-    {
-        // Need space for at least a character and a null terminator.
-        return false;
-    }
-
-    FILE* fp = fopen(fileName, "r");
-    if (fp == NULL)
-    {
-        return false;
-    }
-
-    while (!foundKey && fgets(buffer, bufferLen, fp) != NULL)
-    {
-        char* delimiter = strchr(buffer, '=');
-        if (delimiter == NULL)
-        {
-            // Ignore lines without delimiters.
-            continue;
-        }
-
-        // Change the delimiter character to a NULL for ease of parsing.
-        *delimiter = '\0';
-
-        ADUC_StringUtils_Trim(buffer);
-        foundKey = (strcmp(buffer, key) == 0);
-        if (!foundKey)
-        {
-            continue;
-        }
-
-        char* foundValue = delimiter + 1;
-        ADUC_StringUtils_Trim(foundValue);
-        strncpy(value, foundValue, valueLen);
-        if (value[valueLen - 1] != '\0')
-        {
-            // strncpy pads the buffer with NULL up to valueLen, so if
-            // that position doesn't have a NULL, the buffer provided was too small.
-            foundKey = false;
-            break;
-        }
-    }
-
-    fclose(fp);
-
-    return foundKey;
-}
-
-/**
- * @brief Function that sets @p strBuffers to the contents of the file at @p filePath if the contents are smaller in size than the buffer
- * @param filePath path to the file who's contents will be read
- * @param strBuffer buffer which will be loaded with the contents of @p filePath
- * @param strBuffSize the size of the buffer
- * @returns false on failure, true on success
- */
-_Bool LoadBufferWithFileContents(const char* filePath, char* strBuffer, const size_t strBuffSize)
-{
-    if (filePath == NULL || strBuffer == NULL || strBuffSize == 0)
-    {
-        return false;
-    }
-
-    _Bool success = false;
-
-    // NOLINTNEXTLINE(android-cloexec-open): We are not guaranteed to have access to O_CLOEXEC on all of our builds so no need to include
-    int fd = open(filePath, O_EXCL | O_RDONLY);
-
-    if (fd == -1)
-    {
-        goto done;
-    }
-
-    struct stat bS;
-
-    if (stat(filePath, &bS) != 0)
-    {
-        goto done;
-    }
-
-    long fileSize = bS.st_size;
+// /**
+//  * @brief Read a value from a delimited file and return the value found.
+//  * The file is in form "key=value", and keys are case sensitive.
+//  * Value returned has whitespace trimmed from both ends.
+//  *
+//  * @param fileName Filename of delimited file
+//  * @param key Key to find
+//  * @param value Value found for @p Key
+//  * @param valueLen Size of buffer for @p value
+//  * @return true if value found, false otherwise.
+//  */
+// _Bool ReadDelimitedValueFromFile(const char* fileName, const char* key, char* value, unsigned int valueLen)
+// {
+//     _Bool foundKey = false;
+//     const unsigned int bufferLen = 1024;
+//     char buffer[bufferLen];
+
+//     if (valueLen < 2)
+//     {
+//         // Need space for at least a character and a null terminator.
+//         return false;
+//     }
+
+//     FILE* fp = fopen(fileName, "r");
+//     if (fp == NULL)
+//     {
+//         return false;
+//     }
+
+//     while (!foundKey && fgets(buffer, bufferLen, fp) != NULL)
+//     {
+//         char* delimiter = strchr(buffer, '=');
+//         if (delimiter == NULL)
+//         {
+//             // Ignore lines without delimiters.
+//             continue;
+//         }
+
+//         // Change the delimiter character to a NULL for ease of parsing.
+//         *delimiter = '\0';
+
+//         ADUC_StringUtils_Trim(buffer);
+//         foundKey = (strcmp(buffer, key) == 0);
+//         if (!foundKey)
+//         {
+//             continue;
+//         }
+
+//         char* foundValue = delimiter + 1;
+//         ADUC_StringUtils_Trim(foundValue);
+//         strncpy(value, foundValue, valueLen);
+//         if (value[valueLen - 1] != '\0')
+//         {
+//             // strncpy pads the buffer with NULL up to valueLen, so if
+//             // that position doesn't have a NULL, the buffer provided was too small.
+//             foundKey = false;
+//             break;
+//         }
+//     }
+
+//     fclose(fp);
+
+//     return foundKey;
+// }
+
+// /**
+//  * @brief Function that sets @p strBuffers to the contents of the file at @p filePath if the contents are smaller in size than the buffer
+//  * @param filePath path to the file who's contents will be read
+//  * @param strBuffer buffer which will be loaded with the contents of @p filePath
+//  * @param strBuffSize the size of the buffer
+//  * @returns false on failure, true on success
+//  */
+// _Bool LoadBufferWithFileContents(const char* filePath, char* strBuffer, const size_t strBuffSize)
+// {
+//     if (filePath == NULL || strBuffer == NULL || strBuffSize == 0)
+//     {
+//         return false;
+//     }
+
+//     _Bool success = false;
+
+//     // NOLINTNEXTLINE(android-cloexec-open): We are not guaranteed to have access to O_CLOEXEC on all of our builds so no need to include
+//     int fd = open(filePath, O_EXCL | O_RDONLY);
+
+//     if (fd == -1)
+//     {
+//         goto done;
+//     }
+
+//     struct stat bS;
+
+//     if (stat(filePath, &bS) != 0)
+//     {
+//         goto done;
+//     }
+
+//     long fileSize = bS.st_size;
+
+//     if (fileSize == 0 || fileSize > strBuffSize)
+//     {
+//         goto done;
+//     }
+
+//     size_t numRead = read(fd, strBuffer, fileSize);
+
+//     if (numRead != fileSize)
+//     {
+//         goto done;
+//     }
+
+//     strBuffer[numRead] = '\0';
+
+//     success = true;
+// done:
+
+//     close(fd);
+
+//     if (!success)
+//     {
+//         strBuffer[0] = '\0';
+//     }
+
+//     return success;
+// }
+// /**
+//  * @brief Trim leading and trailing white-spaces. This function modifies the input buffer.
+//  *
+//  * @param str Input string to trim.
+//  * @return Input pointer.
+//  */
+// char* ADUC_StringUtils_Trim(char* str)
+// {
+//     char* begin = str;
+//     char* current = str;
+
+//     if (!str || str[0] == '\0')
+//     {
+//         return str;
+//     }
+
+//     // Find first non white-spaces.
+//     while (isspace((unsigned char)*current))
+//     {
+//         current++;
+//     }
+
+//     char* end = current;
+
+//     // Find the end of the string
+//     while (*end != '\0')
+//     {
+//         end++;
+//     }
+
+//     // back up to the last non-null character
+//     end--;
+
+//     // Find the last non-space character
+//     while (isspace((unsigned char)*end))
+//     {
+//         end--;
+//     }
+
+//     // Shift non-white-space character(s), if needed.
+//     while (current != end + 1)
+//     {
+//         *str++ = *current++;
+//     }
+
+//     *str = '\0';
+
+//     return begin;
+// }
+
+// /**
+//  * @brief Converts string to unsigned long
+//  * Returns false if an input string cannot be converted to unsigned long
+//  * @param[in] string that needs to be converted
+//  * @param[out] converted unsigned long
+//  */
+// _Bool atoul(const char* str, unsigned long* converted)
+// {
+//     if (str == NULL || *str == '\0')
+//     {
+//         return false;
+//     }
+
+//     unsigned long res = 0;
+//     while (*str != '\0')
+//     {
+//         if (*str < '0' || *str > '9')
+//         {
+//             // Not a digit.
+//             return false;
+//         }
+
+//         const unsigned long previous = res;
+//         res = (res * 10) + (*str - '0');
+
+//         if (res < previous)
+//         {
+//             // overflow.
+//             return false;
+//         }
+
+//         ++str;
+//     }
+
+//     *converted = res;
+//     return true;
+// }
+
+// /**
+//  * @brief Converts string to unsigned integer.
+//  * @details Valid range 0 - 4294967295.
+//  * Returns false if string contains invalid char or out of range
+//  * @param[in] string that needs to be converted
+//  * @param[out] converted integer
+//  */
+// _Bool atoui(const char* str, unsigned int* ui)
+// {
+//     if (str == NULL || *str == '\0')
+//     {
+//         return false;
+//     }
+
+//     unsigned int res = 0;
+//     while (*str != '\0')
+//     {
+//         if (*str < '0' || *str > '9')
+//         {
+//             // Not a digit.
+//             return false;
+//         }
+
+//         const unsigned int previous = res;
+//         res = (res * 10) + (*str - '0');
+
+//         if (res < previous)
+//         {
+//             // overflow.
+//             return false;
+//         }
+
+//         ++str;
+//     }
+
+//     *ui = res;
+//     return true;
+// }
+
+// /**
+//  * @brief Split updateType string by ':' to return updateTypeName and updateTypeVersion
+//  * @param[in] updateType - expected "Provider/Name:Version"
+//  * @param[out] updateTypeName - Caller must call free()
+//  * @param[out] updateTypeVersion
+//  */
+// _Bool ADUC_ParseUpdateType(const char* updateType, char** updateTypeName, unsigned int* updateTypeVersion)
+// {
+//     _Bool succeeded = false;
+//     char* name = NULL;
+//     *updateTypeName = NULL;
+//     *updateTypeVersion = 0;
+
+//     if (updateType == NULL)
+//     {
+//         goto done;
+//     }
+
+//     const char* delimiter = strchr(updateType, ':');
+
+//     //delimiter doesn't exist
+//     if (delimiter == NULL)
+//     {
+//         goto done;
+//     }
+
+//     const size_t nameLength = delimiter - updateType;
+
+//     //name is empty
+//     if (nameLength == 0)
+//     {
+//         goto done;
+//     }
+
+//     name = malloc(nameLength + 1);
+//     if (name == NULL)
+//     {
+//         goto done;
+//     }
+
+//     memcpy(name, updateType, nameLength);
+//     name[nameLength] = '\0';
+
+//     // convert version string to unsigned int
+//     if (!atoui(delimiter + 1, updateTypeVersion))
+//     {
+//         // conversion failed
+//         goto done;
+//     }
+
+//     succeeded = true;
+
+// done:
+//     if (succeeded)
+//     {
+//         *updateTypeName = name;
+//     }
+//     else
+//     {
+//         free(name);
+//     }
 
-    if (fileSize == 0 || fileSize > strBuffSize)
-    {
-        goto done;
-    }
-
-    size_t numRead = read(fd, strBuffer, fileSize);
-
-    if (numRead != fileSize)
-    {
-        goto done;
-    }
-
-    strBuffer[numRead] = '\0';
-
-    success = true;
-done:
-
-    close(fd);
-
-    if (!success)
-    {
-        strBuffer[0] = '\0';
-    }
-
-    return success;
-}
-/**
- * @brief Trim leading and trailing white-spaces. This function modifies the input buffer.
- *
- * @param str Input string to trim.
- * @return Input pointer.
- */
-char* ADUC_StringUtils_Trim(char* str)
-{
-    char* begin = str;
-    char* current = str;
-
-    if (!str || str[0] == '\0')
-    {
-        return str;
-    }
-
-    // Find first non white-spaces.
-    while (isspace((unsigned char)*current))
-    {
-        current++;
-    }
-
-    char* end = current;
-
-    // Find the end of the string
-    while (*end != '\0')
-    {
-        end++;
-    }
-
-    // back up to the last non-null character
-    end--;
-
-    // Find the last non-space character
-    while (isspace((unsigned char)*end))
-    {
-        end--;
-    }
-
-    // Shift non-white-space character(s), if needed.
-    while (current != end + 1)
-    {
-        *str++ = *current++;
-    }
-
-    *str = '\0';
-
-    return begin;
-}
-
-/**
- * @brief Converts string to unsigned long
- * Returns false if an input string cannot be converted to unsigned long
- * @param[in] string that needs to be converted
- * @param[out] converted unsigned long
- */
-_Bool atoul(const char* str, unsigned long* converted)
-{
-    if (str == NULL || *str == '\0')
-    {
-        return false;
-    }
-
-    unsigned long res = 0;
-    while (*str != '\0')
-    {
-        if (*str < '0' || *str > '9')
-        {
-            // Not a digit.
-            return false;
-        }
-
-        const unsigned long previous = res;
-        res = (res * 10) + (*str - '0');
-
-        if (res < previous)
-        {
-            // overflow.
-            return false;
-        }
-
-        ++str;
-    }
-
-    *converted = res;
-    return true;
-}
-
-/**
- * @brief Converts string to unsigned integer.
- * @details Valid range 0 - 4294967295.
- * Returns false if string contains invalid char or out of range
- * @param[in] string that needs to be converted
- * @param[out] converted integer
- */
-_Bool atoui(const char* str, unsigned int* ui)
-{
-    if (str == NULL || *str == '\0')
-    {
-        return false;
-    }
-
-    unsigned int res = 0;
-    while (*str != '\0')
-    {
-        if (*str < '0' || *str > '9')
-        {
-            // Not a digit.
-            return false;
-        }
-
-        const unsigned int previous = res;
-        res = (res * 10) + (*str - '0');
-
-        if (res < previous)
-        {
-            // overflow.
-            return false;
-        }
-
-        ++str;
-    }
-
-    *ui = res;
-    return true;
-}
-
-/**
- * @brief Split updateType string by ':' to return updateTypeName and updateTypeVersion
- * @param[in] updateType - expected "Provider/Name:Version"
- * @param[out] updateTypeName - Caller must call free()
- * @param[out] updateTypeVersion
- */
-_Bool ADUC_ParseUpdateType(const char* updateType, char** updateTypeName, unsigned int* updateTypeVersion)
-{
-    _Bool succeeded = false;
-    char* name = NULL;
-    *updateTypeName = NULL;
-    *updateTypeVersion = 0;
-
-    if (updateType == NULL)
-    {
-        goto done;
-    }
-
-    const char* delimiter = strchr(updateType, ':');
-
-    //delimiter doesn't exist
-    if (delimiter == NULL)
-    {
-        goto done;
-    }
-
-    const size_t nameLength = delimiter - updateType;
-
-    //name is empty
-    if (nameLength == 0)
-    {
-        goto done;
-    }
-
-    name = malloc(nameLength + 1);
-    if (name == NULL)
-    {
-        goto done;
-    }
-
-    memcpy(name, updateType, nameLength);
-    name[nameLength] = '\0';
-
-    // convert version string to unsigned int
-    if (!atoui(delimiter + 1, updateTypeVersion))
-    {
-        // conversion failed
-        goto done;
-    }
-
-    succeeded = true;
-
-done:
-    if (succeeded)
-    {
-        *updateTypeName = name;
-    }
-    else
-    {
-        free(name);
-    }
-
-    return succeeded;
-}
+//     return succeeded;
+// }
 
 /**
  * @brief Returns string created by formatting a variable number of string arguments with @p fmt
@@ -374,4 +374,4 @@
     }
 
     return outputStr;
-}
\ Kein Zeilenumbruch am Dateiende.
+}
diff -ruN iot-hub-device-update/src/utils/eis_utils/CMakeLists.txt iot-hub-device-update_new/src/utils/eis_utils/CMakeLists.txt
--- iot-hub-device-update/src/utils/eis_utils/CMakeLists.txt	2021-10-28 12:39:27.289045900 +0200
+++ iot-hub-device-update_new/src/utils/eis_utils/CMakeLists.txt	2021-10-28 12:03:02.509061861 +0200
@@ -2,7 +2,11 @@
 
 project (eis_utils)
 
-add_library (${PROJECT_NAME} STATIC src/eis_utils.c src/eis_coms.c src/eis_err.c)
+# Tell CMake where to find our custom CMake module files.
+set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}")
+
+add_library (${PROJECT_NAME} SHARED src/eis_utils.c src/eis_coms.c src/eis_err.c ../c_utils/src/string_c_utils.c ../../adu_types/src/adu_types.c)
+
 add_library (aduc::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
 target_include_directories (${PROJECT_NAME} PUBLIC inc)
 
@@ -11,10 +15,6 @@
 
 target_link_libraries (
     ${PROJECT_NAME}
-    PUBLIC  aduc::adu_core_interface
-    PRIVATE aduc::adu_types
-            aduc::c_utils
-            aduc::logging
             Parson::parson
             aziotsharedutil
             uhttp)
@@ -25,3 +25,8 @@
 
     add_subdirectory (tests)
 endif ()
+
+install(TARGETS eis_utils DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
+install(DIRECTORY
+    inc/
+    DESTINATION ${CMAKE_INSTALL_PREFIX}/include/eis_utils)
diff -ruN iot-hub-device-update/src/utils/eis_utils/FindParson.cmake iot-hub-device-update_new/src/utils/eis_utils/FindParson.cmake
--- iot-hub-device-update/src/utils/eis_utils/FindParson.cmake	1970-01-01 01:00:00.000000000 +0100
+++ iot-hub-device-update_new/src/utils/eis_utils/FindParson.cmake	2021-10-28 11:26:55.401077692 +0200
@@ -0,0 +1,35 @@
+# Find cmake module for the parson library and header.
+# Exports Parson::parson target
+
+cmake_minimum_required (VERSION 3.5)
+
+include (FindPackageHandleStandardArgs)
+
+find_path (Parson_INCLUDE_DIR
+           NAMES parson.h
+           PATH_SUFFIXES azureiot
+                         azureiot/inc)
+
+find_library (Parson_LIBRARY
+              parson)
+
+find_package_handle_standard_args (Parson
+                                   DEFAULT_MSG
+                                   Parson_INCLUDE_DIR
+                                   Parson_LIBRARY)
+
+if (Parson_FOUND)
+    set (Parson_LIBRARIES ${Parson_LIBRARY})
+    set (Parson_INCLUDE_DIRS ${Parson_INCLUDE_DIR})
+
+    if (NOT TARGET Parson::parson)
+        add_library (Parson::parson
+                     INTERFACE
+                     IMPORTED)
+        set_target_properties (Parson::parson
+                               PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
+                                          "${Parson_INCLUDE_DIRS}"
+                                          INTERFACE_LINK_LIBRARIES
+                                          "${Parson_LIBRARIES}")
+    endif ()
+endif ()
diff -ruN iot-hub-device-update/src/utils/eis_utils/inc/aduc/adu_types.h iot-hub-device-update_new/src/utils/eis_utils/inc/aduc/adu_types.h
--- iot-hub-device-update/src/utils/eis_utils/inc/aduc/adu_types.h	1970-01-01 01:00:00.000000000 +0100
+++ iot-hub-device-update_new/src/utils/eis_utils/inc/aduc/adu_types.h	2021-10-28 12:11:16.625058251 +0200
@@ -0,0 +1,84 @@
+/**
+ * @file adu_type.h
+ * @brief Defines launch arguments and the ConnectionInfo struct used for created the connection between ADU and the IotHub
+ *
+ * @copyright Copyright (c) Microsoft Corporation.
+ */
+#ifndef ADUC_ADU_TYPES_H
+#define ADUC_ADU_TYPES_H
+
+#include "c_utils.h"
+// #include <aduc/logging.h>
+#include <stdbool.h>
+
+EXTERN_C_BEGIN
+/**
+ * @brief ADU Client launch arguments.
+ */
+// typedef struct tagADUC_LaunchArguments
+// {
+//     int argc; /**< Size of argv */
+//     char** argv; /**< Command-line arguments */
+//     ADUC_LOG_SEVERITY logLevel; /**< Log level */
+//     char* connectionString; /**< Device connection string from command-line. */
+//     bool iotHubTracingEnabled; /**< Whether to enable logging from IoT Hub SDK */
+//     bool showVersion; /**< Show an agent version */
+//     bool healthCheckOnly; /**< Only check agent health. Doesn't process any data or messages from services. */
+// } ADUC_LaunchArguments;
+
+typedef enum tagADUC_ConnType
+{
+    ADUC_ConnType_NotSet = 0,
+    ADUC_ConnType_Device = 1,
+    ADUC_ConnType_Module = 2,
+} ADUC_ConnType;
+
+typedef enum tagADUC_AuthType
+{
+    ADUC_AuthType_NotSet = 0,
+    ADUC_AuthType_SASToken = 1,
+    ADUC_AuthType_SASCert = 2,
+    ADUC_AuthType_NestedEdgeCert = 3,
+} ADUC_AuthType;
+
+/**
+ * @brief IoT Hub connection information.
+ */
+typedef struct tagConnectionInfo
+{
+    ADUC_AuthType authType; /**< Indicates the authentication type for connectionString */
+    ADUC_ConnType connType; /**< Indicates whether this connection string is module-id or device-id based */
+    char* connectionString; /**< Device or Module connection string. */
+    char* certificateString; /**< x509 certificate in PEM format for the IoTHubClient to be used for authentication*/
+    char* opensslEngine; /**< identifier for the OpenSSL Engine used for the certificate in certificateString*/
+    char* opensslPrivateKey; /**< x509 private key in PEM format for the IoTHubClient to be used for authentication */
+} ADUC_ConnectionInfo;
+
+/**
+ * @brief DeAllocates the ADUC_ConnectionInfo object
+ * @param info the ADUC_ConnectionInfo object to be de-allocated
+ */
+void ADUC_ConnectionInfo_DeAlloc(ADUC_ConnectionInfo* info);
+
+/**
+ * @brief Returns the string associated with @p connType
+ * @param connType ADUC_ConnType to be stringified
+ * @returns if the ADUC_ConnType exists then the string version of the value is returned, "" otherwise
+ */
+const char* ADUC_ConnType_ToString(const ADUC_ConnType connType);
+
+/**
+ * @brief Scans the connection string and returns the connection type related to the string
+ * @details The connection string must use the valid, correct format for the DeviceId and/or the ModuleId
+ * e.g.
+ * "DeviceId=some-device-id;ModuleId=some-module-id;"
+ * If the connection string contains the DeviceId it is an ADUC_ConnType_Device
+ * If the connection string contains the DeviceId AND the ModuleId it is an ADUC_ConnType_Module
+ * @param connectionString the connection string to scan
+ * @returns the connection type for @p connectionString
+ */
+ADUC_ConnType GetConnTypeFromConnectionString(const char* connectionString);
+
+EXTERN_C_END
+
+#endif // ADUC_ADU_TYPES_H
diff -ruN iot-hub-device-update/src/utils/eis_utils/inc/aduc/c_utils.h iot-hub-device-update_new/src/utils/eis_utils/inc/aduc/c_utils.h
--- iot-hub-device-update/src/utils/eis_utils/inc/aduc/c_utils.h	1970-01-01 01:00:00.000000000 +0100
+++ iot-hub-device-update_new/src/utils/eis_utils/inc/aduc/c_utils.h	2021-10-28 11:00:32.941089252 +0200
@@ -0,0 +1,33 @@
+/**
+ * @file c_utils.h
+ * @brief Helpers and macros for C code.
+ *
+ * @copyright Copyright (c) 2019, Microsoft Corp.
+ */
+#ifndef ADUC_C_UTILS_H
+#define ADUC_C_UTILS_H
+
+#ifdef __cplusplus
+#    define EXTERN_C_BEGIN \
+        extern "C"         \
+        {
+#    define EXTERN_C_END }
+#else
+#    define EXTERN_C_BEGIN
+#    define EXTERN_C_END
+#endif
+
+/**
+ * @brief Gets the size in elements of a statically allocated array.
+ * Do not use on arrays that were allocated on the heap.
+ */
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+/**
+ * @brief Explicitly states that a parameter is not used in this scope.
+ */
+#ifndef UNREFERENCED_PARAMETER
+#    define UNREFERENCED_PARAMETER(param) (void)(param)
+#endif
+
+#endif // ADUC_C_UTILS_H
diff -ruN iot-hub-device-update/src/utils/eis_utils/inc/aduc/string_c_utils.h iot-hub-device-update_new/src/utils/eis_utils/inc/aduc/string_c_utils.h
--- iot-hub-device-update/src/utils/eis_utils/inc/aduc/string_c_utils.h	1970-01-01 01:00:00.000000000 +0100
+++ iot-hub-device-update_new/src/utils/eis_utils/inc/aduc/string_c_utils.h	2021-10-28 12:11:32.561058135 +0200
@@ -0,0 +1,34 @@
+/**
+ * @file string_c_utils.h
+ * @brief String utilities for C code.
+ *
+ * @copyright Copyright (c) 2019, Microsoft Corp.
+ */
+#ifndef ADUC_STRING_C_UTILS_H
+#define ADUC_STRING_C_UTILS_H
+
+#include "c_utils.h"
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+EXTERN_C_BEGIN
+
+char* ADUC_StringUtils_Trim(char* str);
+
+_Bool ADUC_ParseUpdateType(const char* updateType, char** updateTypeName, unsigned int* updateTypeVersion);
+
+_Bool ReadDelimitedValueFromFile(const char* fileName, const char* key, char* value, unsigned int valueLen);
+
+_Bool LoadBufferWithFileContents(const char* filePath, char* strBuffer, const size_t strBuffSize);
+
+_Bool atoul(const char* str, unsigned long* converted);
+
+_Bool atoui(const char* str, unsigned int* ui);
+
+char* ADUC_StringFormat(const char* fmt, ...);
+
+EXTERN_C_END
+
+#endif // ADUC_STRING_C_UTILS_H
diff -ruN iot-hub-device-update/src/utils/eis_utils/inc/eis_coms.h iot-hub-device-update_new/src/utils/eis_utils/inc/eis_coms.h
--- iot-hub-device-update/src/utils/eis_utils/inc/eis_coms.h	2021-10-28 12:39:10.173046025 +0200
+++ iot-hub-device-update_new/src/utils/eis_utils/inc/eis_coms.h	2021-10-28 12:10:03.429058786 +0200
@@ -4,8 +4,8 @@
  *
  * @copyright Copyright (c) 2019, Microsoft Corporation.
  */
-#include <aduc/c_utils.h>
-#include <eis_err.h>
+#include "aduc/c_utils.h"
+#include "eis_err.h"
 #include <time.h>
 #include <umock_c/umock_c_prod.h>
 
@@ -22,7 +22,7 @@
  */
 // clang-format off
 // NOLINTNEXTLINE: clang-tidy doesn't like UMock macro expansions
-MOCKABLE_FUNCTION(, EISErr, RequestIdentitiesFromEIS, 
+MOCKABLE_FUNCTION(, EISErr, RequestIdentitiesFromEIS,
     unsigned int, timeoutMS,
     char**, responseBuffer)
 // clang-format on
@@ -57,11 +57,11 @@
 // clang-format off
 // NOLINTNEXTLINE(cppcoreguidelines-pro-type-cstyle-cast): clang-tidy doesn't like UMock macro expansions
 MOCKABLE_FUNCTION(,EISErr, RequestCertificateFromEIS,
-    const char*, certId, 
-    unsigned int, timeoutMS, 
+    const char*, certId,
+    unsigned int, timeoutMS,
     char**, responseBuffer)
 // clang-format on
 
 EXTERN_C_END
 
-#endif
\ Kein Zeilenumbruch am Dateiende.
+#endif
diff -ruN iot-hub-device-update/src/utils/eis_utils/inc/eis_err.h iot-hub-device-update_new/src/utils/eis_utils/inc/eis_err.h
--- iot-hub-device-update/src/utils/eis_utils/inc/eis_err.h	2021-10-28 12:39:10.173046025 +0200
+++ iot-hub-device-update_new/src/utils/eis_utils/inc/eis_err.h	2021-10-28 12:09:32.601059011 +0200
@@ -4,7 +4,7 @@
  *
  * @copyright Copyright (c) 2020, Microsoft Corporation.
  */
-#include <aduc/c_utils.h>
+#include "aduc/c_utils.h"
 
 #ifndef EIS_ERR_H
 #    define EIS_ERR_H
@@ -41,7 +41,7 @@
 
 /**
  * @brief Returns the string that matches the @p eisErr value
- * @param eisErr error for which 
+ * @param eisErr error for which
  * @returns the string name of the EISErr or "<Unknown>"
  */
 const char* EISErr_ErrToString(EISErr eisErr);
@@ -54,7 +54,7 @@
 const char* EISService_ServiceToString(EISService eisService);
 
 /**
- * @brief Return value for any EIS Utility 
+ * @brief Return value for any EIS Utility
  */
 typedef struct tagEISUtilityResult
 {
@@ -64,4 +64,4 @@
 
 EXTERN_C_END
 
-#endif
\ Kein Zeilenumbruch am Dateiende.
+#endif
diff -ruN iot-hub-device-update/src/utils/eis_utils/inc/eis_utils.h iot-hub-device-update_new/src/utils/eis_utils/inc/eis_utils.h
--- iot-hub-device-update/src/utils/eis_utils/inc/eis_utils.h	2021-10-28 12:39:27.289045900 +0200
+++ iot-hub-device-update_new/src/utils/eis_utils/inc/eis_utils.h	2021-10-28 12:09:22.489059085 +0200
@@ -4,9 +4,9 @@
  *
  * @copyright Copyright (c) 2019, Microsoft Corporation.
  */
-#include <aduc/adu_types.h>
-#include <aduc/c_utils.h>
-#include <eis_err.h>
+#include "aduc/adu_types.h"
+#include "aduc/c_utils.h"
+#include "eis_err.h"
 #include <stddef.h>
 #include <stdint.h>
 #include <time.h>
@@ -23,7 +23,7 @@
 
 /**
  * @brief Creates a connection string using the provisioned data within EIS
- * @details Calls into the EIS Identity and Keyservice to create a SharedAccessSignature which is then used 
+ * @details Calls into the EIS Identity and Keyservice to create a SharedAccessSignature which is then used
  * to create the connection string, Caller is required to call ADUC_ConnectionInfo_DeAlloc() to deallocate the ADUC_ConnectionInfo struct
  * @param[in] expirySecsSinceEpoch the expiration time in seconds since the epoch for the token in the connection string
  * @param[in] timeoutMS the timeoutMS in milliseconds for each call to EIS
@@ -35,4 +35,4 @@
 
 EXTERN_C_END
 
-#endif
\ Kein Zeilenumbruch am Dateiende.
+#endif
diff -ruN iot-hub-device-update/src/utils/eis_utils/src/eis_coms.c iot-hub-device-update_new/src/utils/eis_utils/src/eis_coms.c
--- iot-hub-device-update/src/utils/eis_utils/src/eis_coms.c	2021-10-28 12:39:10.173046025 +0200
+++ iot-hub-device-update_new/src/utils/eis_utils/src/eis_coms.c	2021-10-28 10:51:07.149093385 +0200
@@ -73,7 +73,7 @@
 #define EIS_SIGN_REQUEST_URI EIS_SIGN_URI "?" EIS_API_VERSION
 
 /**
- * @brief URI for the Certificate Service on the Certificate Service's Unix Domain Socket (UDS) 
+ * @brief URI for the Certificate Service on the Certificate Service's Unix Domain Socket (UDS)
  */
 #define EIS_CERT_URI "http://foo/certificates"
 
@@ -139,7 +139,7 @@
 /**
  * @brief Maximum amount of bytes for any EIS response
  */
-#define EIS_RESP_SIZE_MAX 4096
+#define EIS_RESP_SIZE_MAX 16384
 
 //
 // HTTP Functions
@@ -171,7 +171,7 @@
  * @param contentSize the size of @p content
  * @param statusCode the status code for the HTTP response (e.g. 404, 500, 200, etc.)
  * @param responseHeaders header of the response, used in some calls but not needed here
- * 
+ *
  */
 static void on_eis_http_recv(
     void* callbackCtx,
@@ -425,7 +425,7 @@
  * @details The identity response returns the hub hostname, device id, and key handle
  * Caller must release @p responseBuffer with free()
  * @param timeoutMS max timeoutMS for the request in milliseconds
- * @param responseBuffer the buffer that will be allocated by the function to hold the response 
+ * @param responseBuffer the buffer that will be allocated by the function to hold the response
  * @returns Returns a value of EISErr
  */
 EISErr RequestIdentitiesFromEIS(unsigned int timeoutMS, char** responseBuffer)
@@ -592,4 +592,4 @@
     free(requestURI);
 
     return result;
-}
\ Kein Zeilenumbruch am Dateiende.
+}
diff -ruN iot-hub-device-update/src/utils/eis_utils/src/eis_utils.c iot-hub-device-update_new/src/utils/eis_utils/src/eis_utils.c
--- iot-hub-device-update/src/utils/eis_utils/src/eis_utils.c	2021-10-28 12:39:27.289045900 +0200
+++ iot-hub-device-update_new/src/utils/eis_utils/src/eis_utils.c	2021-10-28 10:51:07.153093385 +0200
@@ -22,7 +22,7 @@
 
 /**
  * Example Identity Response:
- * 
+ *
  * {
  *   "type":"aziot",
  *   "spec":{
@@ -36,7 +36,7 @@
  *       }
  *   }
  * }
- * 
+ *
  */
 
 /**
@@ -60,6 +60,12 @@
 #define EIS_IDENTITY_RESP_MODULEID_FIELD "moduleId"
 
 /**
+ * @brief Fieldname for the gatewayHostName provisioned to the IdentityService
+ */
+#define EIS_IDENTITY_RESP_GATEWAYHHOSTNAME_FIELD "gatewayHost"
+
+
+/**
  * @brief Fieldname for the JSON Object which contains the authType and keyHandle
  */
 #define EIS_IDENTITY_RESP_AUTH_FIELD "auth"
@@ -104,7 +110,7 @@
  * {
  *  "pem":"string"
  * }
- * 
+ *
  */
 
 /**
@@ -233,7 +239,8 @@
  * @param deviceId the device identity for the connection string
  * @param moduleId an optional parameter specifying the module identity to use in the connection string
  * @param connType the connection type being used, if EISConnType_ModuleId then moduleId must not be NULL
- * @param sharedAccessSignature the sharedAccessSignature generated for this connection string 
+ * @param sharedAccessSignature the sharedAccessSignature generated for this connection string
+ * @param gatewayHostName an optional parameter specifying the gatewayHostName in a nested environment
  * @param connectionStrPtr the pointer to the buffer which will be allocated for the connection string
  * @returns a value of EISErr
  */
@@ -243,6 +250,7 @@
     const char* moduleId,
     const ADUC_ConnType connType,
     const char* sharedAccessSignature,
+    const char* gatewayHostName,
     char** connectionStrPtr)
 {
     EISErr result = EISErr_Failed;
@@ -277,9 +285,11 @@
             moduleId,
             sharedAccessSignature);
     }
-    else
+
+    if (NULL != gatewayHostName)
     {
-        goto done;
+        connectionStr =
+            ADUC_StringFormat("%s;GatewayHostName=%s", connectionStr, gatewayHostName);
     }
 
     result = EISErr_Ok;
@@ -304,6 +314,7 @@
  * @param deviceId the device identity for the connection string
  * @param moduleId an optional parameter specifying the module identity to use in the connection string
  * @param connType the connection type being used, if EISConnType_ModuleId then moduleId must not be NULL
+ * @param gatewayHostName an optional parameter specifying the gatewayHostName in a nested environment
  * @param connectionStrPtr the pointer to the buffer which will be allocated for the connection string
  * @returns a value of EISErr
  */
@@ -312,6 +323,7 @@
     const char* deviceId,
     const char* moduleId,
     const ADUC_ConnType connType,
+    const char* gatewayHostName,
     char** connectionStrPtr)
 {
     bool success = false;
@@ -346,6 +358,12 @@
         goto done;
     }
 
+    if (NULL != gatewayHostName)
+    {
+        connectionStr =
+            ADUC_StringFormat("%s;GatewayHostName=%s", connectionStr, gatewayHostName);
+    }
+
     result = EISErr_Ok;
     success = true;
 
@@ -368,7 +386,7 @@
 
 /**
  * @brief Creates a connection string using the provisioned data within EIS
- * @details Calls into the EIS Identity and Keyservice to create a SharedAccessSignature which is then used 
+ * @details Calls into the EIS Identity and Keyservice to create a SharedAccessSignature which is then used
  * to create the connection string, Caller is required to call free() to deallocate the connection string
  * @param[in] expirySecsSinceEpoch the expiration time in seconds since the epoch for the token in the connection string
  * @param[in] timeoutMS the timeoutMS in milliseconds for each call to EIS
@@ -474,6 +492,8 @@
         connType = ADUC_ConnType_Module;
     }
 
+    const char* gatewayHostName = json_object_get_string(specJson, EIS_IDENTITY_RESP_GATEWAYHHOSTNAME_FIELD);
+
     // Build request for the signature
     if (connType == ADUC_ConnType_Device)
     {
@@ -533,7 +553,7 @@
         }
 
         result.err =
-            BuildSasTokenConnectionString(hubName, deviceId, moduleId, connType, sharedSignatureStr, &connectionStr);
+            BuildSasTokenConnectionString(hubName, deviceId, moduleId, connType, sharedSignatureStr, gatewayHostName, &connectionStr);
 
         if (result.err != EISErr_Ok)
         {
@@ -594,7 +614,7 @@
             goto done;
         }
 
-        result.err = BuildSasCertConnectionString(hubName, deviceId, moduleId, connType, &connectionStr);
+        result.err = BuildSasCertConnectionString(hubName, deviceId, moduleId, connType, gatewayHostName, &connectionStr);
 
         if (result.err != EISErr_Ok)
         {
@@ -641,4 +661,4 @@
     }
 
     return result;
-}
\ Kein Zeilenumbruch am Dateiende.
+}
